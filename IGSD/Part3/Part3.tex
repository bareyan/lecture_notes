```latex
\documentclass{article}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{graphicx}
\usepackage{color}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{listings}
\usepackage[french]{babel} % Add french package

\newtheorem{theorem}{Théorème} % Renamed theorem environments to French
\newtheorem{lemma}{Lemme}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Définition}
\newtheorem{remark}{Remarque}
\newtheorem{solution}{Solution}
\newtheorem{example}{Exemple}

\usepackage[margin=1in]{geometry}

\begin{document}
\sloppy

\section{Transformations de Modélisation}

En infographie, les transformations géométriques sont fondamentales pour manipuler la position, l'orientation, et la taille des objets dans une scène 2D ou 3D. Ces transformations sont généralement représentées par des matrices et appliquées aux coordonnées des points définissant les objets. Ce chapitre explore différentes transformations de modélisation, leur composition, l'organisation hiérarchique des scènes et les projections pour visualiser des objets 3D sur un écran 2D.

\subsection{Glissement (Shear)}

\begin{definition}
Le \textbf{glissement}, aussi appelé cisaillement (shear), est une transformation qui déforme un objet en déplaçant ses points le long de lignes parallèles. C'est un étirement non uniforme suivant un axe, dont l'amplitude dépend de la distance à une ligne ou un plan de référence.
\end{definition}

\subsubsection{Glissement parallèle à l'axe x}
La matrice d'un glissement parallèle à l'axe des x, où la coordonnée x d'un point est augmentée proportionnellement à sa coordonnée y avec un rapport k, est donnée par :
\[
M_{shear\_x} = \begin{pmatrix}
1 & k & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\]
Un point $P = (x, y, z, 1)^T$ est transformé en $P' = (x + ky, y, z, 1)^T$.

\begin{verbatim}
#save_to: shear_x.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, ax = plt.subplots()

# Original square
original = patches.Polygon([[0,0], [1,0], [1,1], [0,1]], closed=True, fill=False, edgecolor='black', linestyle='--')
ax.add_patch(original)

# Sheared square (k=0.5)
k = 0.5
sheared = patches.Polygon([[0,0], [1,0], [1+k*1,1], [0+k*1,1]], closed=True, fill=True, edgecolor='red', facecolor='red', alpha=0.5)
ax.add_patch(sheared)

# Arrows
ax.arrow(0.5, 1, k, 0, head_width=0.1, head_length=0.1, fc='red', ec='red')
ax.text(0.5 + k/2, 1.1, 'k', color='red', ha='center', va='bottom')


ax.set_xlim(-0.5, 2)
ax.set_ylim(-0.5, 2)
ax.set_aspect('equal', adjustable='box')
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_title("Glissement parallèle à x (k=0.5)")
ax.grid(True)

plt.savefig('shear_x.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.5\textwidth, keepaspectratio]{shear_x.png}
\caption{Illustration d'un glissement parallèle à l'axe x.}
\label{fig:shear_x}
\end{figure}

\subsubsection{Glissement parallèle à l'axe x avec ligne de base}
Si le glissement parallèle à l'axe x de rapport k s'effectue par rapport à une ligne de base horizontale $y = y_{ref}$, la matrice de transformation devient :
\[
M_{shear\_x\_ref} = \begin{pmatrix}
1 & k & 0 & -k \cdot y_{ref} \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\]
Un point $P = (x, y, z, 1)^T$ est transformé en $P' = (x + k(y - y_{ref}), y, z, 1)^T$.

\begin{verbatim}
#save_to: shear_x_ref.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, ax = plt.subplots()

# Original square
original = patches.Polygon([[0,0], [1,0], [1,1], [0,1]], closed=True, fill=False, edgecolor='black', linestyle='--')
ax.add_patch(original)

# Sheared square (k=0.5, y_ref = -1)
k = 0.5
y_ref = -1
sheared = patches.Polygon([[0 + k*(0-y_ref),0], [1 + k*(0-y_ref),0], [1 + k*(1-y_ref),1], [0 + k*(1-y_ref),1]], closed=True, fill=True, edgecolor='red', facecolor='red', alpha=0.5)
ax.add_patch(sheared)

# Line y=y_ref
ax.axhline(y=y_ref, color='blue', linestyle='-.', label=f'y_ref={y_ref}')

# Arrows indicating shear relative to y_ref
ax.arrow(0.5, 1, k*(1-y_ref), 0, head_width=0.1, head_length=0.1, fc='red', ec='red', length_includes_head=True)
ax.arrow(0.5, 0, k*(0-y_ref), 0, head_width=0.1, head_length=0.1, fc='red', ec='red', length_includes_head=True)

# Add text for the line reference point
ax.text(1.5, y_ref, f'y_ref={y_ref}', color='blue', va='center')

ax.set_xlim(-1, 3)
ax.set_ylim(-2, 2)
ax.set_aspect('equal', adjustable='box')
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_title(f"Glissement parallèle à x (k={k}, y_ref={y_ref})")
ax.grid(True)

plt.savefig('shear_x_ref.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.5\textwidth, keepaspectratio]{shear_x_ref.png}
\caption{Illustration d'un glissement parallèle à l'axe x par rapport à une ligne de base $y_{ref}$.}
\label{fig:shear_x_ref}
\end{figure}

\section{Composition de Transformations}

Il est souvent nécessaire d'appliquer plusieurs transformations successives à un objet. La composition de transformations consiste à combiner plusieurs matrices de transformation en une seule matrice équivalente.

\subsection{Multiplication de matrices}
Si un point $p$ est d'abord transformé par une matrice $M_1$ puis par une matrice $M_2$, le point résultant $p''$ est obtenu par $p'' = M_2 \cdot (M_1 \cdot p)$. Grâce à l'associativité de la multiplication matricielle, cela peut s'écrire $p'' = (M_2 \cdot M_1) \cdot p$. La matrice composée $M = M_2 \cdot M_1$ représente l'effet combiné des deux transformations.

\begin{example}[Homothétie puis Translation]
Considérons un point $p$ auquel on applique d'abord une mise à l'échelle $S(s_x, s_y)$ puis une translation $T(t_x, t_y)$. Le point transformé $p'$ est $p' = T \cdot (S \cdot p) = (T \cdot S) \cdot p$.

Soit $S = S(2,2)$ et $T = T(3,1)$. Les matrices correspondantes en coordonnées homogènes 2D (en étendant à 3x3 pour simplifier) sont :
\[
S = \begin{pmatrix} 2 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & 1 \end{pmatrix}, \quad
T = \begin{pmatrix} 1 & 0 & 3 \\ 0 & 1 & 1 \\ 0 & 0 & 1 \end{pmatrix}
\]
La matrice composée $T \cdot S$ est :
\[
T \cdot S = \begin{pmatrix} 1 & 0 & 3 \\ 0 & 1 & 1 \\ 0 & 0 & 1 \end{pmatrix} \cdot
            \begin{pmatrix} 2 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & 1 \end{pmatrix} =
            \begin{pmatrix} (1\cdot2+0\cdot0+3\cdot0) & (1\cdot0+0\cdot2+3\cdot0) & (1\cdot0+0\cdot0+3\cdot1) \\
                            (0\cdot2+1\cdot0+1\cdot0) & (0\cdot0+1\cdot2+1\cdot0) & (0\cdot0+1\cdot0+1\cdot1) \\
                            (0\cdot2+0\cdot0+1\cdot0) & (0\cdot0+0\cdot2+1\cdot0) & (0\cdot0+0\cdot0+1\cdot1) \end{pmatrix} =
            \begin{pmatrix} 2 & 0 & 3 \\ 0 & 2 & 1 \\ 0 & 0 & 1 \end{pmatrix}
\]

Appliquons cela à un point $p = (1, 1)^T$, représenté en coordonnées homogènes par $p_{hom} = (1, 1, 1)^T$.
$S \cdot p_{hom} = (2, 2, 1)^T$. Le point est mis à l'échelle à $(2, 2)$.
$T \cdot (S \cdot p_{hom}) = T \cdot (2, 2, 1)^T = (2+3, 2+1, 1)^T = (5, 3, 1)^T$. Le point final est $(5, 3)$.
Vérifions avec la matrice composée :
$(T \cdot S) \cdot p_{hom} = \begin{pmatrix} 2 & 0 & 3 \\ 0 & 2 & 1 \\ 0 & 0 & 1 \end{pmatrix} \cdot \begin{pmatrix} 1 \\ 1 \\ 1 \end{pmatrix} = \begin{pmatrix} 2\cdot1 + 0\cdot1 + 3\cdot1 \\ 0\cdot1 + 2\cdot1 + 1\cdot1 \\ 0\cdot1 + 0\cdot1 + 1\cdot1 \end{pmatrix} = \begin{pmatrix} 5 \\ 3 \\ 1 \end{pmatrix}$. Le résultat est identique.
\end{example}

\begin{verbatim}
#save_to: composition_scale_translate.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, ax = plt.subplots()

# Original point
p0 = np.array([0,0])
p1 = np.array([1,1])

# Scale(2,2)
S = np.array([[2, 0], [0, 2]])
p2 = S @ p1

# Translate(3,1)
T = np.array([3, 1])
p3 = p2 + T

# Plot points
ax.plot(p1[0], p1[1], 'bo', label='p=(1,1)')
ax.plot(p2[0], p2[1], 'go', label="p'=S.p=(2,2)")
ax.plot(p3[0], p3[1], 'ro', label="p''=T.p'=(5,3)")

# Plot transformations
ax.arrow(p0[0], p0[1], p1[0]-p0[0], p1[1]-p0[1], head_width=0.2, head_length=0.3, fc='blue', ec='blue', length_includes_head=True)
ax.text(p1[0]*0.5, p1[1]*0.5, '(1,1)', color='blue', ha='right', va='bottom')

ax.arrow(p0[0], p0[1], p2[0]-p0[0], p2[1]-p0[1], head_width=0.2, head_length=0.3, fc='green', ec='green', length_includes_head=True, linestyle='--')
ax.text(p2[0]*0.5, p2[1]*0.5, 'Scale(2,2)', color='green', ha='right', va='bottom', rotation=45)
ax.text(p2[0], p2[1]+0.1, '(2,2)', color='green', ha='center', va='bottom')


# Translation vector from origin for visualization
p_trans_origin = T
ax.arrow(p0[0], p0[1], p_trans_origin[0], p_trans_origin[1], head_width=0.2, head_length=0.3, fc='orange', ec='orange', length_includes_head=True, linestyle=':')
ax.text(p_trans_origin[0], p_trans_origin[1], '(3,1)', color='orange', ha='left', va='bottom')

# The actual translation applied to p'
ax.arrow(p2[0], p2[1], T[0], T[1], head_width=0.2, head_length=0.3, fc='red', ec='red', length_includes_head=True, linestyle='--')
ax.text(p2[0] + T[0]/2, p2[1] + T[1]/2 + 0.1, 'Translate(3,1)', color='red', ha='center', va='bottom')
ax.text(p3[0], p3[1]+0.1, '(5,3)', color='red', ha='center', va='bottom')


ax.set_xlim(-1, 6)
ax.set_ylim(-1, 4)
ax.set_aspect('equal', adjustable='box')
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_title("Composition : Scale(2,2) puis Translate(3,1)")
ax.grid(True)
ax.legend()

plt.savefig('composition_scale_translate.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.8\textwidth, keepaspectratio]{composition_scale_translate.png}
\caption{Composition d'une homothétie suivie d'une translation.}
\label{fig:composition_scale_translate}
\end{figure}

\subsection{Non-commutativité}
La multiplication de matrices n'est généralement pas commutative, c'est-à-dire $M_1 \cdot M_2 \neq M_2 \cdot M_1$. L'ordre dans lequel les transformations sont appliquées est donc crucial.

\begin{example}[Translation puis Homothétie]
Reprenons les transformations $S = S(2,2)$ et $T = T(3,1)$. Appliquons-les dans l'ordre inverse : d'abord la translation, puis l'homothétie. Le point transformé est $p' = S \cdot (T \cdot p) = (S \cdot T) \cdot p$.

La matrice composée $S \cdot T$ est :
\[
S \cdot T = \begin{pmatrix} 2 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & 1 \end{pmatrix} \cdot
            \begin{pmatrix} 1 & 0 & 3 \\ 0 & 1 & 1 \\ 0 & 0 & 1 \end{pmatrix} =
            \begin{pmatrix} (2\cdot1+0\cdot0+0\cdot0) & (2\cdot0+0\cdot1+0\cdot0) & (2\cdot3+0\cdot1+0\cdot1) \\
                            (0\cdot1+2\cdot0+0\cdot0) & (0\cdot0+2\cdot1+0\cdot0) & (0\cdot3+2\cdot1+0\cdot1) \\
                            (0\cdot1+0\cdot0+1\cdot0) & (0\cdot0+0\cdot1+1\cdot0) & (0\cdot3+0\cdot1+1\cdot1) \end{pmatrix} =
            \begin{pmatrix} 2 & 0 & 6 \\ 0 & 2 & 2 \\ 0 & 0 & 1 \end{pmatrix}
\]
On observe que $S \cdot T \neq T \cdot S$.

Appliquons cela au point $p = (1, 1)^T$, soit $p_{hom} = (1, 1, 1)^T$.
$T \cdot p_{hom} = (1+3, 1+1, 1)^T = (4, 2, 1)^T$. Le point est translaté à $(4, 2)$.
$S \cdot (T \cdot p_{hom}) = S \cdot (4, 2, 1)^T = (2\cdot4, 2\cdot2, 1)^T = (8, 4, 1)^T$. Le point final est $(8, 4)$.
Vérifions avec la matrice composée :
$(S \cdot T) \cdot p_{hom} = \begin{pmatrix} 2 & 0 & 6 \\ 0 & 2 & 2 \\ 0 & 0 & 1 \end{pmatrix} \cdot \begin{pmatrix} 1 \\ 1 \\ 1 \end{pmatrix} = \begin{pmatrix} 2\cdot1 + 0\cdot1 + 6\cdot1 \\ 0\cdot1 + 2\cdot1 + 2\cdot1 \\ 0\cdot1 + 0\cdot1 + 1\cdot1 \end{pmatrix} = \begin{pmatrix} 8 \\ 4 \\ 1 \end{pmatrix}$. Le résultat est $(8,4)$, ce qui est différent de $(5,3)$ obtenu précédemment.
\end{example}

\begin{verbatim}
#save_to: composition_translate_scale.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, ax = plt.subplots()

# Original point
p0 = np.array([0,0])
p1 = np.array([1,1])

# Translate(3,1)
T = np.array([3, 1])
p2 = p1 + T

# Scale(2,2) from origin
S = np.array([[2, 0], [0, 2]])
p3 = S @ p2

# Plot points
ax.plot(p1[0], p1[1], 'bo', label='p=(1,1)')
ax.plot(p2[0], p2[1], 'mo', label="p'=T.p=(4,2)")
ax.plot(p3[0], p3[1], 'co', label="p''=S.p'=(8,4)")

# Plot transformations
# Vector for original point
ax.arrow(p0[0], p0[1], p1[0]-p0[0], p1[1]-p0[1], head_width=0.3, head_length=0.4, fc='blue', ec='blue', length_includes_head=True)
ax.text(p1[0]*0.5, p1[1]*0.5, '(1,1)', color='blue', ha='right', va='bottom')

# Translation vector
ax.arrow(p1[0], p1[1], T[0], T[1], head_width=0.3, head_length=0.4, fc='magenta', ec='magenta', length_includes_head=True, linestyle='--')
ax.text(p1[0] + T[0]/2, p1[1] + T[1]/2 + 0.1, 'Translate(3,1)', color='magenta', ha='center', va='bottom')
ax.text(p2[0], p2[1]+0.1, '(4,2)', color='magenta', ha='center', va='bottom')

# Scaling from origin
ax.arrow(p0[0], p0[1], p2[0]-p0[0], p2[1]-p0[1], head_width=0.3, head_length=0.4, fc='magenta', ec='magenta', length_includes_head=True, linestyle=':')
ax.arrow(p0[0], p0[1], p3[0]-p0[0], p3[1]-p0[1], head_width=0.3, head_length=0.4, fc='cyan', ec='cyan', length_includes_head=True, linestyle='--')
ax.text(p3[0]*0.5, p3[1]*0.5, 'Scale(2,2)', color='cyan', ha='right', va='top', rotation=27)
ax.text(p3[0], p3[1]+0.1, '(8,4)', color='cyan', ha='center', va='bottom')


ax.set_xlim(-1, 9)
ax.set_ylim(-1, 5)
ax.set_aspect('equal', adjustable='box')
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_title("Composition : Translate(3,1) puis Scale(2,2)")
ax.grid(True)
ax.legend()

plt.savefig('composition_translate_scale.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.8\textwidth, keepaspectratio]{composition_translate_scale.png}
\caption{Composition d'une translation suivie d'une homothétie (comparez avec la Figure \ref{fig:composition_scale_translate}).}
\label{fig:composition_translate_scale}
\end{figure}

\subsection{Ordre d'application}
Comme $p'' = M_2 \cdot M_1 \cdot p$, la transformation $M_1$ est appliquée en premier au point $p$, suivie de la transformation $M_2$ appliquée au résultat. L'ordre d'application des transformations se lit donc **de droite à gauche** dans le produit matriciel.

\subsection{Cas général}
Pour une séquence de transformations représentées par les matrices $M_1, M_2, ..., M_n$, appliquées dans cet ordre à un point $p$, le point transformé $p'$ est donné par :
\[ p' = M_n \cdot M_{n-1} \cdot ... \cdot M_2 \cdot M_1 \cdot p \]
On peut précalculer la matrice de transformation globale $M = M_n \cdot M_{n-1} \cdot ... \cdot M_2 \cdot M_1$. Alors, $p' = M \cdot p$.

\subsection{Transformations par rapport à un point arbitraire}
Les transformations élémentaires (rotation, mise à l'échelle) sont définies par rapport à l'origine du repère. Pour effectuer une transformation par rapport à un point arbitraire $P(t_x, t_y, t_z)$, on utilise une composition de trois transformations :
\begin{enumerate}
    \item Ramener le point $P$ à l'origine en appliquant une translation $T(-t_x, -t_y, -t_z)$.
    \item Appliquer la transformation souhaitée (par exemple, une rotation $R(\theta)$ ou une mise à l'échelle $S(s_x, s_y, s_z)$).
    \item Replacer le point $P$ à sa position initiale en appliquant la translation inverse $T(t_x, t_y, t_z)$.
\end{enumerate}
La matrice de transformation résultante $M$ est le produit de ces trois matrices :
\[ M = T(t_x, t_y, t_z) \cdot R(\theta) \cdot T(-t_x, -t_y, -t_z) \]
ou
\[ M = T(t_x, t_y, t_z) \cdot S(s_x, s_y, s_z) \cdot T(-t_x, -t_y, -t_z) \]

\begin{example}[Rotation autour d'un axe passant par P]
On désire effectuer une rotation d'angle $\theta_z$ autour d'un axe parallèle à l'axe $z$ et passant par le point $P(T_x, T_y, T_z)$.
La matrice de transformation $M$ est :
\[ M = T(T_x, T_y, T_z) \cdot R_z(\theta_z) \cdot T(-T_x, -T_y, -T_z) \]
où $R_z(\theta_z)$ est la matrice de rotation autour de l'axe z :
\[
R_z(\theta_z) = \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & 0 \\
\sin\theta_z & \cos\theta_z & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\]
Les matrices de translation sont :
\[
T(T_x, T_y, T_z) = \begin{pmatrix} 1 & 0 & 0 & T_x \\ 0 & 1 & 0 & T_y \\ 0 & 0 & 1 & T_z \\ 0 & 0 & 0 & 1 \end{pmatrix}, \quad
T(-T_x, -T_y, -T_z) = \begin{pmatrix} 1 & 0 & 0 & -T_x \\ 0 & 1 & 0 & -T_y \\ 0 & 0 & 1 & -T_z \\ 0 & 0 & 0 & 1 \end{pmatrix}
\]
Effectuons le produit matriciel $M = T \cdot R_z \cdot T^{-1}$:
\begin{align*}
R_z \cdot T^{-1} &= \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & 0 \\
\sin\theta_z & \cos\theta_z & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix} \cdot \begin{pmatrix} 1 & 0 & 0 & -T_x \\ 0 & 1 & 0 & -T_y \\ 0 & 0 & 1 & -T_z \\ 0 & 0 & 0 & 1 \end{pmatrix} \\
&= \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & -T_x \cos\theta_z + T_y \sin\theta_z \\
\sin\theta_z & \cos\theta_z & 0 & -T_x \sin\theta_z - T_y \cos\theta_z \\
0 & 0 & 1 & -T_z \\
0 & 0 & 0 & 1
\end{pmatrix}
\end{align*}
\begin{align*}
M = T \cdot (R_z \cdot T^{-1}) &= \begin{pmatrix} 1 & 0 & 0 & T_x \\ 0 & 1 & 0 & T_y \\ 0 & 0 & 1 & T_z \\ 0 & 0 & 0 & 1 \end{pmatrix} \cdot \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & -T_x \cos\theta_z + T_y \sin\theta_z \\
\sin\theta_z & \cos\theta_z & 0 & -T_x \sin\theta_z - T_y \cos\theta_z \\
0 & 0 & 1 & -T_z \\
0 & 0 & 0 & 1
\end{pmatrix} \\
&= \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & -T_x \cos\theta_z + T_y \sin\theta_z + T_x \\
\sin\theta_z & \cos\theta_z & 0 & -T_x \sin\theta_z - T_y \cos\theta_z + T_y \\
0 & 0 & 1 & -T_z + T_z \\
0 & 0 & 0 & 1
\end{pmatrix} \\
&= \begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & T_x(1-\cos\theta_z) + T_y \sin\theta_z \\
\sin\theta_z & \cos\theta_z & 0 & T_y(1-\cos\theta_z) - T_x \sin\theta_z \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\end{align*}
Cette matrice $M$ applique directement la rotation souhaitée autour de l'axe passant par $P(T_x, T_y, T_z)$.
(Note : La diapositive 4 contenait une erreur dans le calcul final de la matrice M, elle a été corrigée ici.)
\end{example}

\begin{verbatim}
#save_to: rotation_around_point.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, axs = plt.subplots(1, 3, figsize=(12, 4), sharex=True, sharey=True)
fig.suptitle("Rotation autour d'un axe parallèle à z passant par P")

# Point P and Object (Hexagon centered at origin for simplicity before translation)
center_P = np.array([2.0, 1.0])
angle_rad = np.pi / 4 # 45 degrees rotation

# Object vertices (relative to origin)
radius = 0.5
angles = np.linspace(0, 2*np.pi, 7)[:-1]
obj_rel = radius * np.array([np.cos(angles), np.sin(angles)]).T

# 1. Initial State
ax = axs[0]
ax.set_title("1. Objet initial")
obj_initial_abs = obj_rel + center_P
polygon_initial = patches.Polygon(obj_initial_abs, closed=True, fill=True, facecolor='lightblue')
ax.add_patch(polygon_initial)
ax.plot(center_P[0], center_P[1], 'ro', label='P (Centre rotation)')
ax.text(center_P[0], center_P[1]+0.1, f'P({center_P[0]},{center_P[1]})', color='red')
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.grid(True)
ax.set_aspect('equal', adjustable='box')
ax.legend()

# 2. Translate to Origin -> Rotate -> Translate Back
# Translate object so P is at origin
obj_translated_to_origin = obj_initial_abs - center_P

# Rotation Matrix (2D)
R = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],
              [np.sin(angle_rad), np.cos(angle_rad)]])

# Rotate around origin
obj_rotated_at_origin = (R @ obj_translated_to_origin.T).T

# Translate back
obj_final = obj_rotated_at_origin + center_P

# Plot intermediate steps (conceptually)
# Step 2: Translate P to Origin
ax = axs[1]
ax.set_title("2. T(-Px,-Py)")
polygon_t = patches.Polygon(obj_translated_to_origin, closed=True, fill=True, facecolor='lightgreen', alpha=0.7)
ax.add_patch(polygon_t)
ax.plot(0, 0, 'ro') # P is now at origin
ax.plot(center_P[0], center_P[1], 'ro', alpha=0.3) # Original P position
ax.arrow(center_P[0], center_P[1], -center_P[0], -center_P[1], head_width=0.1, head_length=0.1, fc='gray', ec='gray', linestyle=':')
ax.grid(True)
ax.set_aspect('equal', adjustable='box')

# Step 3: Rotate Rz(theta) then Translate T(Px,Py)
ax = axs[2]
ax.set_title("3. Rz(theta) puis T(Px,Py)")
polygon_r = patches.Polygon(obj_rotated_at_origin, closed=True, fill=True, facecolor='lightcoral', alpha=0.5) # Rotated at origin
ax.add_patch(polygon_r)
polygon_final = patches.Polygon(obj_final, closed=True, fill=True, facecolor='lightblue') # Final position
ax.add_patch(polygon_final)
ax.plot(center_P[0], center_P[1], 'ro') # P position
ax.arrow(0, 0, center_P[0], center_P[1], head_width=0.1, head_length=0.1, fc='gray', ec='gray', linestyle=':')
ax.grid(True)
ax.set_aspect('equal', adjustable='box')


for ax_ in axs:
    ax_.set_xlim(0, 4)
    ax_.set_ylim(0, 3)

plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust layout to prevent title overlap
plt.savefig('rotation_around_point.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth, keepaspectratio]{rotation_around_point.png}
\caption{Étapes de la rotation d'un objet autour d'un point P.}
\label{fig:rotation_around_point}
\end{figure}

\section{Modélisation Hiérarchique}

Pour décrire des objets ou des scènes complexes composés de plusieurs parties, on utilise souvent une approche de modélisation hiérarchique.

\subsection{Concept et avantages}
\begin{itemize}
    \item Un modèle hiérarchique permet de décrire facilement des objets complexes composés d'objets plus simples (primitives).
    \item La scène est organisée sous forme d'une structure arborescente (ou plus généralement, un graphe).
    \item Les objets ne sont plus définis par leur transformation absolue par rapport au repère global (monde), mais par leur transformation relative par rapport à leur parent dans l'arbre.
    \item Le repère associé à la racine de l'arbre est le repère de la scène (repère monde).
    \item À chaque nœud de l'arbre est associé un repère local.
    \item À chaque arc (reliant un parent à un enfant) est associée une transformation géométrique qui positionne l'objet fils dans le repère de son père.
    \item Un même objet (ou sous-arbre) peut être inclus plusieurs fois dans la hiérarchie (instanciation), ce qui permet de réutiliser des modèles.
    \item La structure résultante est un graphe orienté acyclique (Directed Acyclic Graph - DAG), car un objet ne peut pas être son propre ancêtre.
\end{itemize}

\begin{verbatim}
#save_to: scene_graph_dag.png
from graphviz import Digraph

dot = Digraph(comment='Graphe de Scène Simple', graph_attr={'rankdir': 'TB'})

# Nodes
dot.node('Root', 'Virtual Universe (Root)', shape='box')
dot.node('Locale1', 'Hi-Res Locale', shape='ellipse')
dot.node('BranchGroup1', 'Branch Group Node', shape='diamond')
dot.node('Group1', 'Group Node', shape='invtriangle')
dot.node('Group2', 'Group Node', shape='invtriangle')
dot.node('Leaf1', 'Leaf Node 1 (Geometry)', shape='triangle')
dot.node('Leaf2', 'Leaf Node 2 (Geometry)', shape='triangle')
dot.node('Leaf3', 'Leaf Node 3 (Geometry)', shape='triangle')
dot.node('Leaf4', 'Leaf Node 4 (Geometry)', shape='triangle')

# Edges with Transform Labels (Conceptual)
dot.edge('Root', 'Locale1', label='T_locale')
dot.edge('Locale1', 'BranchGroup1', label='T_branch')
dot.edge('BranchGroup1', 'Group1', label='T_group1')
dot.edge('BranchGroup1', 'Group2', label='T_group2')
dot.edge('Group1', 'Leaf1', label='T_leaf1')
dot.edge('Group1', 'Leaf2', label='T_leaf2')
dot.edge('Group2', 'Leaf3', label='T_leaf3')
dot.edge('Group2', 'Leaf4', label='T_leaf4')

# Indicate DAG property (conceptual)
dot.edge('Group1', 'Leaf3', label='T_shared_leaf3', style='dashed') # Example of instancing

dot.render('scene_graph_dag', format='png', view=False)
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.7\textwidth, keepaspectratio]{scene_graph_dag.png}
\caption{Exemple de structure hiérarchique sous forme de Graphe Orienté Acyclique (DAG).}
\label{fig:scene_graph_dag}
\end{figure}

\subsection{Construction du graphe}
La construction d'un modèle hiérarchique se fait souvent par un processus descendant ("top-down") :
\begin{enumerate}
    \item On part de l'objet complet (racine).
    \item On le décompose récursivement en parties plus simples (nœuds internes).
    \item On continue la décomposition jusqu'à obtenir des objets élémentaires indécomposables, appelés primitives géométriques (feuilles de l'arbre).
\end{enumerate}
La séquence de transformations le long d'un chemin depuis la racine jusqu'à un nœud feuille définit la position et l'orientation finale de la primitive correspondante dans le repère monde. Cette séquence est appelée la chaîne cinématique.

\begin{example}[Modélisation d'une maison simple]
On peut modéliser une maison comme un assemblage d'un corps principal et d'un toit. Le corps principal peut être décomposé en murs, fenêtres, porte. Les fenêtres peuvent être composées d'un cadre et d'une vitre, etc.

\begin{verbatim}
#save_to: simple_house.png
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

fig, ax = plt.subplots()

# Main building body
main_body = patches.Rectangle((1, 0), 4, 3, fill=True, facecolor='lightgrey', edgecolor='black')
ax.add_patch(main_body)

# Roof
roof = patches.Polygon([[1, 3], [5, 3], [3, 4.5]], fill=True, facecolor='darkred', edgecolor='black')
ax.add_patch(roof)

# Door
door = patches.Rectangle((1.5, 0), 1, 2, fill=True, facecolor='brown', edgecolor='black')
ax.add_patch(door)

# Windows (using loops for potential multiple windows)
win_width = 0.8
win_height = 1.0
win_y = 1.5
win_x_start = 3.0
win_spacing = 0.2

for i in range(2):
    win_x = win_x_start + i * (win_width + win_spacing)
    window = patches.Rectangle((win_x, win_y), win_width, win_height, fill=True, facecolor='lightblue', edgecolor='black')
    ax.add_patch(window)
    # Window crossbars
    ax.plot([win_x, win_x + win_width], [win_y + win_height/2, win_y + win_height/2], color='black', linewidth=1)
    ax.plot([win_x + win_width/2, win_x + win_width/2], [win_y, win_y + win_height], color='black', linewidth=1)

# Garage (simpler representation)
garage_body = patches.Rectangle((-1, 0), 2, 2.5, fill=True, facecolor='tan', edgecolor='black')
ax.add_patch(garage_body)
garage_roof = patches.Polygon([[-1, 2.5], [1, 2.5], [0, 3.5]], fill=True, facecolor='grey', edgecolor='black')
ax.add_patch(garage_roof)
garage_door = patches.Rectangle((-0.7, 0), 1.4, 2, fill=True, facecolor='darkgrey', edgecolor='black')
ax.add_patch(garage_door)


ax.set_xlim(-2, 6)
ax.set_ylim(-1, 5)
ax.set_aspect('equal', adjustable='box')
ax.set_title("Exemple de Maison Simple (Modélisation Hiérarchique)")
ax.axis('off') # Turn off axes for a cleaner look

plt.savefig('simple_house.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.6\textwidth, keepaspectratio]{simple_house.png}
\caption{Illustration d'une maison simple pouvant être modélisée hiérarchiquement.}
\label{fig:simple_house}
\end{figure}

Le graphe de scène correspondant pourrait ressembler à ceci :

\begin{verbatim}
#save_to: house_scene_graph.png
from graphviz import Digraph

dot = Digraph(comment='Graphe de Scène Maison', graph_attr={'rankdir': 'TB'})

# Nodes
dot.node('Maison', 'Maison (Tm)', shape='box')
dot.node('Garage', 'Garage (Tg)', shape='ellipse')
dot.node('Corps', 'Corps principal (Tc)', shape='ellipse')
dot.node('PorteGa', 'Porte a (Tga)', shape='invtriangle')
dot.node('PorteGb', 'Porte b (Tgb)', shape='invtriangle')
dot.node('Facade', 'Facade (Tfa)', shape='diamond')
dot.node('ToitC', 'Toit', shape='invtriangle') # Toit du corps principal
dot.node('Fen1', 'Fenetre 1 (Tf1)', shape='invtriangle')
dot.node('Fen2', 'Fenetre 2', shape='invtriangle')
dot.node('Fen3', 'Fenetre 3', shape='invtriangle')
dot.node('Fen4', 'Fenetre 4', shape='invtriangle')
dot.node('Fen5', 'Fenetre 5', shape='invtriangle')
dot.node('VitreA', 'Vitre a (Tva)', shape='triangle')
dot.node('CadreA', 'Cadre a', shape='triangle') # Assuming window parts

# Edges
dot.edge('Maison', 'Garage', label='Tg')
dot.edge('Maison', 'Corps', label='Tc')
dot.edge('Garage', 'PorteGa', label='Tga')
dot.edge('Garage', 'PorteGb', label='Tgb') # Assuming two garage doors
dot.edge('Corps', 'Facade', label='Tfa')
dot.edge('Corps', 'ToitC') # Maybe Toit transformation is part of Corps Tc
dot.edge('Facade', 'Fen1', label='Tf1')
dot.edge('Facade', 'Fen2', label='Tf2') # Assume Tf2..Tf5 exist
dot.edge('Facade', 'Fen3', label='Tf3')
dot.edge('Facade', 'Fen4', label='Tf4')
dot.edge('Facade', 'Fen5', label='Tf5')
dot.edge('Fen1', 'VitreA', label='Tva')
dot.edge('Fen1', 'CadreA') # Assume Tca exists

# Placeholder for other window parts
dot.node('...', '...', shape='plaintext')
dot.edge('Fen2','...')
dot.edge('Fen3','...')
dot.edge('Fen4','...')
dot.edge('Fen5','...')
dot.edge('VitreA', 'Geometry_Vitre', shape='point') # Conceptual geometry node

dot.render('house_scene_graph', format='png', view=False)
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.9\textwidth, keepaspectratio]{house_scene_graph.png}
\caption{Exemple de graphe de scène pour la modélisation d'une maison.}
\label{fig:house_scene_graph}
\end{figure}
\end{example}

\subsection{Pile de transformations}
Pour déterminer la transformation globale d'un objet feuille dans le repère monde, on multiplie toutes les matrices de transformation rencontrées le long du chemin depuis la racine jusqu'à la feuille. C'est la "Current Transformation Matrix" (CTM).
Par exemple, pour trouver la transformation de la `Vitre a` dans la Figure \ref{fig:house_scene_graph} par rapport à la `Maison` (racine), on calcule :
\[ M_{vitreA} = T_m \cdot T_c \cdot T_{fa} \cdot T_{f1} \cdot T_{va} \]
où chaque $T$ représente la matrice de transformation associée à l'arc correspondant dans le graphe. L'implémentation se fait souvent à l'aide d'une pile (stack) pour gérer la CTM lors du parcours du graphe.

\subsection{Instanciation (Instancing)}
L'instanciation permet de réutiliser une définition d'objet (géométrie ou sous-graphe) à plusieurs endroits dans la scène sans dupliquer sa description.
\begin{itemize}
    \item On définit l'objet une seule fois.
    \item Dans le graphe de scène, on utilise des nœuds "pointeurs" ou des références vers cette définition unique.
    \item Chaque instance (chaque pointeur) peut avoir sa propre transformation associée sur l'arc entrant, permettant de positionner, orienter et mettre à l'échelle chaque copie différemment.
\end{itemize}
Cela économise de la mémoire et facilite les modifications : changer la définition originale affecte toutes ses instances.

\begin{verbatim}
#save_to: instancing_graph.png
from graphviz import Digraph

dot = Digraph(comment='Instancing Example', graph_attr={'rankdir': 'TB'})

# Define the object once
with dot.subgraph(name='cluster_Dandelion') as sub:
    sub.attr(label='Dandelion Definition', style='filled', color='lightgrey')
    sub.node('Dand_Geom', 'Geometry', shape='triangle')
    sub.node('Dand_Root', 'Dandelion Root', shape='ellipse')
    sub.edge('Dand_Root', 'Dand_Geom')

# Scene Root
dot.node('Root', 'Scene Root', shape='box')

# Instances
dot.node('Instance1', 'Instance A1', shape='diamond')
dot.node('Instance2', 'Instance A2', shape='diamond')
dot.node('Instance3', 'Instance A3', shape='diamond')

# Edges from Root to Instances with unique transforms
dot.edge('Root', 'Instance1', label='Transform A1')
dot.edge('Root', 'Instance2', label='Transform A2')
dot.edge('Root', 'Instance3', label='Transform A3')

# Edges from Instances pointing to the *same* definition root
dot.edge('Instance1', 'Dand_Root', style='dashed', label='points to')
dot.edge('Instance2', 'Dand_Root', style='dashed', label='points to')
dot.edge('Instance3', 'Dand_Root', style='dashed', label='points to')


dot.render('instancing_graph', format='png', view=False)
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.7\textwidth, keepaspectratio]{instancing_graph.png}
\caption{Graphe de scène illustrant l'instanciation : plusieurs nœuds (Instances A1, A2, A3) pointent vers la même définition d'objet (Dandelion) mais avec des transformations différentes.}
\label{fig:instancing_graph}
\end{figure}

\section{Changement de Repère}

Il est souvent nécessaire d'exprimer les coordonnées d'un point ou la description d'un objet dans différents systèmes de coordonnées (repères). Par exemple :
\begin{itemize}
    \item Repère objet : Coordonnées locales à l'objet.
    \item Repère scène (ou monde) : Coordonnées globales de la scène.
    \item Repère caméra (ou vue) : Coordonnées par rapport à l'observateur.
\end{itemize}
Le passage d'un repère à un autre s'effectue à l'aide d'une matrice de changement de repère.

\subsection{Matrice de passage}
Soient deux repères $R_1$ (origine $O_1$, axes $X_1, Y_1, Z_1$) et $R_2$ (origine $O_2$, axes $X_2, Y_2, Z_2$). Soit un point $P$ dont les coordonnées sont $P_1 = (x_1, y_1, z_1, 1)^T$ dans $R_1$ et $P_2 = (x_2, y_2, z_2, 1)^T$ dans $R_2$.

La matrice de passage $M_{2 \to 1}$ permet de passer des coordonnées dans $R_2$ aux coordonnées dans $R_1$ :
\[ P_1 = M_{2 \to 1} \cdot P_2 \]
La matrice $M_{2 \to 1}$ exprime les vecteurs de base et l'origine de $R_2$ dans le repère $R_1$. Si $O_2 = (T_x, T_y, T_z)$ dans $R_1$ et les vecteurs directeurs des axes $X_2, Y_2, Z_2$ ont pour coordonnées $(R_{11}, R_{21}, R_{31})$, $(R_{12}, R_{22}, R_{32})$, et $(R_{13}, R_{23}, R_{33})$ respectivement dans $R_1$, alors :
\[
M_{2 \to 1} = \begin{pmatrix}
R_{11} & R_{12} & R_{13} & T_x \\
R_{21} & R_{22} & R_{23} & T_y \\
R_{31} & R_{32} & R_{33} & T_z \\
0 & 0 & 0 & 1
\end{pmatrix} = \begin{pmatrix} & & & \\ X_2|_{R1} & Y_2|_{R1} & Z_2|_{R1} & O_2|_{R1} \\ & & & \\ 0 & 0 & 0 & 1 \end{pmatrix}
\]
La sous-matrice 3x3 contenant les $R_{ij}$ est une matrice de rotation (si les repères sont orthonormés et de même orientation) et le vecteur $(T_x, T_y, T_z)$ est le vecteur de translation de $O_1$ vers $O_2$ exprimé dans $R_1$.

Pour passer des coordonnées de $R_1$ à $R_2$, on utilise la matrice inverse $M_{1 \to 2} = (M_{2 \to 1})^{-1}$:
\[ P_2 = M_{1 \to 2} \cdot P_1 = (M_{2 \to 1})^{-1} \cdot P_1 \]
Si $M_{2 \to 1}$ représente une transformation rigide (rotation + translation), son inverse est relativement simple à calculer :
\[ (M_{2 \to 1})^{-1} = \begin{pmatrix} R^T & -R^T \cdot T \\ 0 & 1 \end{pmatrix} \]
où $R$ est la matrice de rotation 3x3 et $T$ est le vecteur de translation $(T_x, T_y, T_z)^T$.

\begin{verbatim}
#save_to: change_basis.png
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots()

# Repere R1 (Noir)
O1 = np.array([0, 0])
X1_dir = np.array([1, 0])
Y1_dir = np.array([0, 1])

ax.arrow(O1[0], O1[1], X1_dir[0], X1_dir[1], head_width=0.1, head_length=0.15, fc='black', ec='black')
ax.arrow(O1[0], O1[1], Y1_dir[0], Y1_dir[1], head_width=0.1, head_length=0.15, fc='black', ec='black')
ax.text(O1[0] + X1_dir[0], O1[1] + X1_dir[1], 'X1', color='black', va='bottom', ha='left')
ax.text(O1[0] + Y1_dir[0], O1[1] + Y1_dir[1], 'Y1', color='black', va='bottom', ha='right')
ax.plot(O1[0], O1[1], 'ko', label='O1')

# Repere R2 (Rouge) - Rotated by 30 deg, Translated by (2, 1) relative to R1
angle_rad = np.deg2rad(30)
R_mat = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],
                  [np.sin(angle_rad), np.cos(angle_rad)]])
O2_in_R1 = np.array([2, 1])
X2_in_R1 = R_mat @ np.array([1, 0])
Y2_in_R1 = R_mat @ np.array([0, 1])

ax.arrow(O2_in_R1[0], O2_in_R1[1], X2_in_R1[0], X2_in_R1[1], head_width=0.1, head_length=0.15, fc='red', ec='red')
ax.arrow(O2_in_R1[0], O2_in_R1[1], Y2_in_R1[0], Y2_in_R1[1], head_width=0.1, head_length=0.15, fc='red', ec='red')
ax.text(O2_in_R1[0] + X2_in_R1[0], O2_in_R1[1] + X2_in_R1[1], 'X2', color='red', va='bottom', ha='left')
ax.text(O2_in_R1[0] + Y2_in_R1[0], O2_in_R1[1] + Y2_in_R1[1], 'Y2', color='red', va='bottom', ha='left')
ax.plot(O2_in_R1[0], O2_in_R1[1], 'ro', label='O2')

# Point P
P_in_R2 = np.array([0.5, 0.8]) # Coordinates in R2
# Calculate P_in_R1 = O2_in_R1 + Px_R2 * X2_in_R1 + Py_R2 * Y2_in_R1
P_in_R1 = O2_in_R1 + P_in_R2[0] * X2_in_R1 + P_in_R2[1] * Y2_in_R1
ax.plot(P_in_R1[0], P_in_R1[1], 'bo', label='P')
ax.text(P_in_R1[0], P_in_R1[1]+0.1, 'P', color='blue')

# Show coordinates (optional visualization)
# Vector O2->P in R2 basis shown in R1
ax.plot([O2_in_R1[0], O2_in_R1[0] + P_in_R2[0]*X2_in_R1[0]], [O2_in_R1[1], O2_in_R1[1] + P_in_R2[0]*X2_in_R1[1]], 'r:') # X2 component
ax.plot([O2_in_R1[0] + P_in_R2[0]*X2_in_R1[0], P_in_R1[0]], [O2_in_R1[1] + P_in_R2[0]*X2_in_R1[1], P_in_R1[1]], 'r:') # Y2 component

ax.set_xlim(-1, 4)
ax.set_ylim(-1, 3)
ax.set_aspect('equal', adjustable='box')
ax.set_title("Changement de repère de R2 vers R1")
ax.grid(True)
ax.legend()

plt.savefig('change_basis.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.6\textwidth, keepaspectratio]{change_basis.png}
\caption{Illustration du changement de repère. Les coordonnées du point P peuvent être exprimées dans R1 ou R2.}
\label{fig:change_basis}
\end{figure}

\section{Projections}

La projection est le processus qui transforme les objets d'un espace 3D en une représentation 2D, telle qu'elle apparaîtrait sur un écran ou une image. C'est une étape essentielle du pipeline graphique.

\subsection{Pipeline Graphique simplifié}
Les étapes principales pour afficher une scène 3D incluent :
\begin{enumerate}
    \item \textbf{Transformations de modélisation :} Positionner/orienter/mettre à l'échelle les objets dans le repère monde.
    \item \textbf{Transformation d'affichage (vue) :} Placer la caméra et transformer les coordonnées du repère monde vers le repère caméra.
    \item \textbf{Illumination (Shading) :} Calculer les couleurs des objets en fonction des lumières et des matériaux (pas traité ici).
    \item \textbf{Clipping :} Éliminer les parties de la scène qui sont en dehors du volume de vue de la caméra.
    \item \textbf{Projection :} Transformer les coordonnées 3D (du repère caméra) en coordonnées 2D sur le plan de projection.
    \item \textbf{Transformation écran (Viewport) :} Mapper les coordonnées 2D projetées vers les coordonnées pixels de l'écran.
    \item \textbf{Pixelisation (Rasterization) :} Déterminer quels pixels sont couverts par chaque primitive projetée.
    \item \textbf{Visibilité / Rendu :} Déterminer quelles surfaces sont visibles (élimination des parties cachées) et affecter les couleurs finales aux pixels.
\end{enumerate}

\begin{verbatim}
#save_to: graphics_pipeline.png
from graphviz import Digraph

dot = Digraph(comment='Pipeline Graphique', graph_attr={'rankdir': 'TB'})

dot.node('Model', 'Transformations de\nmodélisation', shape='box', style='filled', color='lightblue')
dot.node('View', 'Transformation\nd\'affichage (Vue)', shape='box', style='filled', color='lightblue')
dot.node('Shading', 'Illumination\n(Shading)', shape='box', style='filled', color='lightgrey') # Mentioned but not focus
dot.node('Clip', 'Clipping', shape='box', style='filled', color='lightblue')
dot.node('Project', 'Transformation écran\n(Projection)', shape='box', style='filled', color='lightblue')
dot.node('Raster', 'Pixelisation\n(Rasterization)', shape='box', style='filled', color='lightblue')
dot.node('Render', 'Visibilité / Rendu', shape='box', style='filled', color='lightblue')

dot.edge('Model', 'View')
dot.edge('View', 'Shading')
dot.edge('Shading', 'Clip')
dot.edge('Clip', 'Project')
dot.edge('Project', 'Raster')
dot.edge('Raster', 'Render')


dot.render('graphics_pipeline', format='png', view=False)
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.5\textwidth, keepaspectratio]{graphics_pipeline.png}
\caption{Étapes principales du pipeline graphique.}
\label{fig:graphics_pipeline}
\end{figure}

\subsection{Définition et Types}
La projection consiste à définir des \textbf{projecteurs} (lignes de projection) qui passent par chaque point de l'objet 3D et intersectent un \textbf{plan de projection} (ou plan de vue). L'ensemble de ces intersections forme l'image 2D projetée de l'objet.

Il existe deux grandes familles de projections géométriques :
\begin{enumerate}
    \item \textbf{Projection Perspective :} Les projecteurs convergent en un point unique appelé \textbf{Centre de Projection (CP)} ou point de vue. Ce CP est situé à une distance finie du plan de projection. Elle simule la vision humaine et photographique (les objets lointains paraissent plus petits).
    \item \textbf{Projection Parallèle :} Les projecteurs sont parallèles entre eux. Cela correspond à un CP situé à l'infini. Elle préserve les rapports de taille et les angles pour les faces parallèles au plan de projection, utile pour les dessins techniques.
\end{enumerate}

\begin{verbatim}
#save_to: projection_types.png
import matplotlib.pyplot as plt
import numpy as np

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

# --- Perspective Projection ---
ax = axs[0]
ax.set_title("Projection Perspective")

# Projection Plane (Line in 2D)
plane_y = 0
ax.plot([-2, 2], [plane_y, plane_y], 'k-', label='Plan de Projection')

# Center of Projection (CP)
cp = np.array([0, -3])
ax.plot(cp[0], cp[1], 'ro', label='Centre de Projection (CP)')

# Object (Segment AB in 3D, represented by two points in 2D view)
obj_A = np.array([-1, -1])
obj_B = np.array([1, -1.5])
ax.plot([obj_A[0], obj_B[0]], [obj_A[1], obj_B[1]], 'b-', lw=2, label='Objet 3D (segment AB)')

# Projectors (lines from CP through object points)
# Line CP-A: y = (obj_A[1]-cp[1])/(obj_A[0]-cp[0]) * (x - cp[0]) + cp[1]
slope_A = (obj_A[1]-cp[1])/(obj_A[0]-cp[0]) if obj_A[0]!=cp[0] else np.inf
proj_A_x = cp[0] + (plane_y - cp[1]) / slope_A if slope_A != 0 and slope_A != np.inf else obj_A[0] if slope_A == np.inf else np.nan
proj_A = np.array([proj_A_x, plane_y])

slope_B = (obj_B[1]-cp[1])/(obj_B[0]-cp[0]) if obj_B[0]!=cp[0] else np.inf
proj_B_x = cp[0] + (plane_y - cp[1]) / slope_B if slope_B != 0 and slope_B != np.inf else obj_B[0] if slope_B == np.inf else np.nan
proj_B = np.array([proj_B_x, plane_y])

ax.plot([cp[0], obj_A[0]], [cp[1], obj_A[1]], 'g--', label='Projecteurs')
ax.plot([cp[0], obj_B[0]], [cp[1], obj_B[1]], 'g--')

# Projection (Segment ab)
ax.plot([proj_A[0], proj_B[0]], [proj_A[1], proj_B[1]], 'm-', lw=3, label='Projection 2D (segment ab)')
ax.plot(proj_A[0], proj_A[1], 'mo')
ax.plot(proj_B[0], proj_B[1], 'mo')
ax.text(proj_A[0]-0.1, proj_A[1]+0.1, 'a')
ax.text(proj_B[0]+0.1, proj_B[1]+0.1, 'b')

ax.set_xlim(-2.5, 2.5)
ax.set_ylim(-4, 1)
ax.set_aspect('equal', adjustable='box')
ax.grid(True)
ax.legend()

# --- Parallel Projection ---
ax = axs[1]
ax.set_title("Projection Parallèle")

# Projection Plane
ax.plot([-2, 2], [plane_y, plane_y], 'k-', label='Plan de Projection')

# Object (Segment AB) - Same object
ax.plot([obj_A[0], obj_B[0]], [obj_A[1], obj_B[1]], 'b-', lw=2, label='Objet 3D (segment AB)')

# Projectors (Parallel lines, e.g., vertical)
proj_dir = np.array([0, 1]) # Direction vector of projection (from object to plane)
# Projection points
proj_A_p = obj_A + (plane_y - obj_A[1])/proj_dir[1] * proj_dir if proj_dir[1] != 0 else np.array([obj_A[0], plane_y])
proj_B_p = obj_B + (plane_y - obj_B[1])/proj_dir[1] * proj_dir if proj_dir[1] != 0 else np.array([obj_B[0], plane_y])

ax.plot([obj_A[0], proj_A_p[0]], [obj_A[1], proj_A_p[1]], 'g--', label='Projecteurs (parallèles)')
ax.plot([obj_B[0], proj_B_p[0]], [obj_B[1], proj_B_p[1]], 'g--')

# Projection (Segment ab)
ax.plot([proj_A_p[0], proj_B_p[0]], [proj_A_p[1], proj_B_p[1]], 'm-', lw=3, label='Projection 2D (segment ab)')
ax.plot(proj_A_p[0], proj_A_p[1], 'mo')
ax.plot(proj_B_p[0], proj_B_p[1], 'mo')
ax.text(proj_A_p[0]-0.1, proj_A_p[1]+0.1, 'a')
ax.text(proj_B_p[0]+0.1, proj_B_p[1]+0.1, 'b')

ax.set_xlim(-2.5, 2.5)
ax.set_ylim(-4, 1)
ax.set_aspect('equal', adjustable='box')
ax.grid(True)
ax.legend()

plt.tight_layout()
plt.savefig('projection_types.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth, keepaspectratio]{projection_types.png}
\caption{Comparaison entre projection perspective (gauche) et parallèle (droite).}
\label{fig:projection_types}
\end{figure}

\subsection{Taxonomie des Projections}

\begin{verbatim}
#save_to: projection_taxonomy.png
from graphviz import Digraph

dot = Digraph(comment='Taxonomie des Projections')

# Main Categories
dot.node('Proj', 'Projections', shape='box')
dot.node('Parallel', 'Parallèle', shape='ellipse')
dot.node('Perspective', 'Perspective', shape='ellipse')

# Parallel Subcategories
dot.node('Ortho', 'Orthographique', shape='invtriangle')
dot.node('Oblique', 'Oblique', shape='invtriangle')

# Orthographic Subcategories
dot.node('Axes', 'Axes principaux\n(Multivues)', shape='triangle')
dot.node('Axon', 'Axonométrique', shape='triangle')

# Multiview Subcategories
dot.node('Top', 'Top (Vue de dessus)', shape='plaintext')
dot.node('Front', 'Front (Vue de face)', shape='plaintext')
dot.node('Side', 'Side (Vue de côté)', shape='plaintext')

# Oblique Subcategories
dot.node('Cavalier', 'Cavalier', shape='triangle')
dot.node('Cabinet', 'Cabinet', shape='triangle')
dot.node('OtherO', 'Autre', shape='triangle')

# Perspective Subcategories
dot.node('P1', '1 point', shape='triangle')
dot.node('P2', '2 points', shape='triangle')
dot.node('P3', '3 points', shape='triangle')

# Edges
dot.edge('Proj', 'Parallel')
dot.edge('Proj', 'Perspective')

dot.edge('Parallel', 'Ortho')
dot.edge('Parallel', 'Oblique')

dot.edge('Ortho', 'Axes')
dot.edge('Ortho', 'Axon') # Axonometric is also Orthographic

dot.edge('Axes', 'Top')
dot.edge('Axes', 'Front')
dot.edge('Axes', 'Side')

dot.edge('Oblique', 'Cavalier')
dot.edge('Oblique', 'Cabinet')
dot.edge('Oblique', 'OtherO')

dot.edge('Perspective', 'P1')
dot.edge('Perspective', 'P2')
dot.edge('Perspective', 'P3')


dot.render('projection_taxonomy', format='png', view=False)
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.8\textwidth, keepaspectratio]{projection_taxonomy.png}
\caption{Classification des projections géométriques.}
\label{fig:projection_taxonomy}
\end{figure}

\subsection{Projections Parallèles}
Dans une projection parallèle, la direction de projection (DP) est constante pour tous les points.
\textbf{Propriétés :}
\begin{itemize}
    \item Les lignes parallèles dans l'espace 3D restent parallèles dans l'image 2D projetée.
    \item Les rapports des distances le long d'une direction donnée sont conservés.
    \item Peu réaliste (pas d'effet de perspective), mais utile pour les dessins techniques et les mesures exactes car les dimensions relatives sont préservées pour les faces parallèles au plan de projection.
\end{itemize}

\subsubsection{Projection Orthographique}
Les projecteurs sont parallèles entre eux ET perpendiculaires au plan de projection.
\begin{itemize}
    \item \textbf{Vues Multiples (Axes principaux) :} Le plan de projection est parallèle à l'un des plans de coordonnées principaux (xy, yz, xz). On obtient les vues de face (Front), de dessus (Top), et de côté (Side). Mathématiquement, cela revient à annuler une des coordonnées. Par exemple, pour une projection sur le plan z=0 (vue de dessus), on met la coordonnée z à 0.
    \item \textbf{Axonométrique :} Le plan de projection n'est pas parallèle aux plans de coordonnées. Plusieurs faces de l'objet sont visibles simultanément. Le vecteur normal au plan de projection n'est parallèle à aucun des axes de coordonnées. (Isométrique, Dimétrique, Trimétrique selon les angles).
\end{itemize}

\textbf{Matrice de Projection Orthographique (sur plan z=0)} :
Pour projeter un point $P = (x, y, z, 1)^T$ sur le plan $z=0$ (vue de dessus), le point projeté est $P' = (x, y, 0, 1)^T$. La matrice correspondante est :
\[
M_{ortho\_z} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\]
De même pour les projections sur les plans x=0 et y=0 :
\[
M_{ortho\_x} = \begin{pmatrix}
0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}, \quad
M_{ortho\_y} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\]

\subsubsection{Projection Oblique}
Les projecteurs sont parallèles entre eux mais \textbf{non perpendiculaires} au plan de projection. L'angle $\phi$ entre les projecteurs et le plan est différent de 90°.
\begin{itemize}
    \item Les faces parallèles au plan de projection sont projetées sans déformation.
    \item Les faces perpendiculaires au plan de projection sont déformées (lignes projetées avec un angle $\alpha$ et un facteur de raccourcissement $f$).
    \item \textbf{Projection Cavalière :} L'angle $\phi = 45°$. Les lignes perpendiculaires au plan de projection ne sont pas raccourcies ($f=1$). L'angle $\alpha$ est souvent choisi à 30° ou 45°. Apparence déformée.
    \item \textbf{Projection Cabinet :} L'angle $\phi \approx 63.4°$ ($\cot \phi = 1/2$). Les lignes perpendiculaires au plan sont raccourcies de moitié ($f=1/2$). Apparence plus réaliste que la cavalière. L'angle $\alpha$ est souvent choisi à 30° ou 45°.
\end{itemize}
La matrice d'une projection oblique est une combinaison d'une transformation de glissement (shear) suivie d'une projection orthographique.

\subsection{Projection Perspective}
Dans une projection perspective, les projecteurs émanent d'un point unique, le Centre de Projection (CP).
\textbf{Propriétés :}
\begin{itemize}
    \item Non-linéaire (en coordonnées cartésiennes, mais linéaire en coordonnées homogènes).
    \item Ne conserve pas le parallélisme (sauf pour les lignes parallèles au plan de projection).
    \item Ne conserve pas les angles ni les rapports de distance (sauf cas particuliers).
    \item La taille projetée d'un objet diminue lorsque sa distance au CP augmente (effet de perspective).
    \item Les ensembles de lignes parallèles dans l'espace 3D (qui ne sont pas parallèles au plan de projection) convergent vers un point unique dans l'image projetée, appelé \textbf{point de fuite}.
    \item Le nombre de points de fuite (1, 2 ou 3) dépend de l'orientation des axes principaux de l'objet par rapport au plan de projection.
\end{itemize}

\subsubsection{Calcul de la Projection Perspective (Vue de côté simplifiée)}
Considérons une caméra simple (sténopé) avec le CP à l'origine (0,0,0) et le plan de projection à $z = -f$ (ou $z=f$ selon la convention, ici utilisons $z=f$ comme sur certaines slides, bien que $z=-f$ soit plus courant pour un système droitier regardant vers -z). Soit un point 3D $P(x, y, z)$ et son projeté $q(u, v)$ sur le plan $z=f$.

Par Thalès (triangles semblables) :
\[ \frac{u}{x} = \frac{f}{z} \implies u = \frac{x \cdot f}{z} = \frac{x}{z/f} \]
\[ \frac{v}{y} = \frac{f}{z} \implies v = \frac{y \cdot f}{z} = \frac{y}{z/f} \]
Si $f=1$ (plan de projection unitaire) :
\[ u = \frac{x}{z}, \quad v = \frac{y}{z} \]

\begin{verbatim}
#save_to: perspective_side_view.png
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots()

# Configuration: CP at origin, looking along +z, projection plane at z=f
cp = np.array([0, 0]) # Center of Projection (at origin in this view)
f = 2 # Focal length / distance to projection plane
proj_plane_z = f

# Point P in 3D (represented by z, y coordinates in side view)
p_z = 5
p_y = 3
p = np.array([p_z, p_y]) # Use z for horizontal axis in this side view

# Projection q on the plane z=f
# v/y = f/z => v = y*f/z
q_z = f
q_y = p_y * f / p_z
q = np.array([q_z, q_y])

# Plotting
ax.plot([0, proj_plane_z+3], [0, 0], 'k-', label='Axe z') # Optical axis (z)
ax.plot([proj_plane_z, proj_plane_z], [-1, 4], 'b-', label=f'Plan Projection (z={f})')
ax.plot(cp[0], cp[1], 'ro', label='CP (Sténopé C)')
ax.plot(p[0], p[1], 'go', label=f'Objet 3D P (z={p_z}, y={p_y})')
ax.plot(q[0], q[1], 'mo', label=f'Projection q (z={q_z:.1f}, v={q_y:.2f})')

# Projector line
ax.plot([cp[0], p[0]], [cp[1], p[1]], 'g--', label='Projecteur')

# Lines for similar triangles
ax.plot([0, p[0]], [0, p[1]], 'r:') # Hypotenuse large triangle
ax.plot([p[0], p[0]], [0, p[1]], 'g:') # Height P
ax.text(p[0]+0.1, p[1]/2, 'y', color='g')
ax.plot([0, p[0]], [0, 0], 'g:') # Base P
ax.text(p[0]/2, -0.2, 'z', color='g')

ax.plot([0, q[0]], [0, q[1]], 'r:') # Hypotenuse small triangle
ax.plot([q[0], q[0]], [0, q[1]], 'm:') # Height q (v)
ax.text(q[0]+0.1, q[1]/2, 'v', color='m')
ax.plot([0, q[0]], [0, 0], 'm:') # Base q (f)
ax.text(q[0]/2, -0.4, 'f', color='m')


ax.set_xlabel("Distance z")
ax.set_ylabel("Hauteur y / v")
ax.set_title("Projection Perspective (Vue de côté y-z)")
ax.set_xlim(-1, 6)
ax.set_ylim(-1, 4)
ax.set_aspect('equal', adjustable='box')
ax.grid(True)
ax.legend(fontsize='small')

plt.savefig('perspective_side_view.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=0.7\textwidth, keepaspectratio]{perspective_side_view.png}
\caption{Calcul de la projection perspective en utilisant les triangles semblables (vue de côté y-z).}
\label{fig:perspective_side_view}
\end{figure}

\subsubsection{Matrice de Projection Perspective (simple)}
En coordonnées homogènes, la projection perspective $u = xf/z$, $v = yf/z$ peut être représentée par une matrice. L'astuce est que la division par $z$ est effectuée lors de la renormalisation des coordonnées homogènes (division par la 4ème composante $w$).
On cherche une matrice $M_{persp}$ telle que :
\[
\begin{pmatrix} x' \\ y' \\ z' \\ w' \end{pmatrix} = M_{persp} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}
\quad \text{et} \quad u = \frac{x'}{w'}, v = \frac{y'}{w'}
\]
Une matrice possible (qui projette sur $z=0$ après division, et préserve z pour le Z-buffering, avec CP à l'origine) est :
\[
M_{persp} = \begin{pmatrix}
f & 0 & 0 & 0 \\
0 & f & 0 & 0 \\
0 & 0 & f & 0 \\ % Conserve z ou le mappe, ici juste f*z
0 & 0 & 1 & 0  % w' = z
\end{pmatrix}
 \quad \text{ou plus couramment} \quad
M_{persp} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\ % Conserve z ou le mappe
0 & 0 & 1/f & 0  % w' = z/f
\end{pmatrix}
\]
Appliquons la seconde matrice :
\[
\begin{pmatrix} x' \\ y' \\ z' \\ w' \end{pmatrix} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 1/f & 0
\end{pmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ y \\ z \\ z/f \end{pmatrix}
\]
Après division par $w' = z/f$, on obtient les coordonnées cartésiennes projetées :
\[ u = \frac{x'}{w'} = \frac{x}{z/f} = \frac{xf}{z} \]
\[ v = \frac{y'}{w'} = \frac{y}{z/f} = \frac{yf}{z} \]
La coordonnée $z_{proj} = z'/w' = z/(z/f) = f$ est constante (tous les points se projettent sur le plan $z=f$), ce qui n'est pas idéal pour la gestion de la profondeur (Z-buffer). Des matrices plus complexes sont utilisées en pratique pour mapper l'intervalle de profondeur $[z_{near}, z_{far}]$ vers un intervalle normalisé (e.g., $[-1, 1]$).

La matrice présentée sur la diapositive 16 (droite) semble correspondre à une projection sur $z=0$ avec le CP à $(0, 0, -f)$ regardant vers $+z$.
$x_p = \frac{x}{-z/f + 1}$, $y_p = \frac{y}{-z/f + 1}$.
La matrice homogène correspondante est :
\[
M_{persp} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\ % Ou 0 0 0 0 si on projette sur z=0
0 & 0 & -1/f & 1
\end{pmatrix}
\]
Vérifions :
\[
\begin{pmatrix} x' \\ y' \\ z' \\ w' \end{pmatrix} = M_{persp} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ y \\ z \\ -z/f + 1 \end{pmatrix}
\]
Après division par $w' = -z/f + 1$ :
\[ x_p = \frac{x}{-z/f + 1}, \quad y_p = \frac{y}{-z/f + 1} \]
Ceci correspond aux formules données.

\subsubsection{Effet de la distance focale (f)}
\begin{itemize}
    \item Plus $f$ est \textbf{grand} (téléobjectif), plus la projection tend vers une projection parallèle (orthographique). La profondeur a peu d'effet sur la taille projetée, la perspective est moins marquée ("écrasée").
    \item Plus $f$ est \textbf{petit} (grand angle), plus la projection diverge. La profondeur a une influence considérable, les effets de perspective sont exagérés (distorsion possible près des bords).
\end{itemize}

\begin{verbatim}
#save_to: perspective_focal_length.png
import matplotlib.pyplot as plt
import numpy as np

fig, axs = plt.subplots(1, 2, figsize=(10, 5), sharey=True)
fig.suptitle("Effet de la distance focale (f) sur la projection perspective")

# Common elements
cp_z = 0 # CP at z=0
obj_z1 = 5
obj_z2 = 8
obj_y = 2 # Same height object at two depths

# --- Small f (Wide Angle) ---
ax = axs[0]
f1 = 1.0
proj_plane_z1 = f1
ax.set_title(f"f = {f1} (Petit - Grand Angle)")
ax.plot([proj_plane_z1, proj_plane_z1], [-0.5, 3], 'b-', label=f'Plan Projection (z={f1})')

# Projections
proj1_y1 = obj_y * f1 / obj_z1
proj2_y1 = obj_y * f1 / obj_z2
ax.plot([obj_z1, obj_z1], [0, obj_y], 'g-', lw=2, label='Objet (proche)')
ax.plot([obj_z2, obj_z2], [0, obj_y], 'm-', lw=2, label='Objet (loin)')
ax.plot([cp_z, obj_z1], [0, obj_y], 'g:') # Projector 1
ax.plot([cp_z, obj_z2], [0, obj_y], 'm:') # Projector 2
ax.plot([proj_plane_z1, proj_plane_z1], [0, proj1_y1], 'g-', lw=4, label=f'Proj 1 (h={proj1_y1:.2f})')
ax.plot([proj_plane_z1, proj_plane_z1], [0, proj2_y1], 'm-', lw=4, label=f'Proj 2 (h={proj2_y1:.2f})')
ax.plot(cp_z, 0, 'ro', label='CP')
ax.grid(True)
ax.legend(fontsize='small', loc='upper right')
ax.set_xlabel("z")
ax.set_ylabel("y / hauteur projetée")


# --- Large f (Telephoto) ---
ax = axs[1]
f2 = 4.0
proj_plane_z2 = f2
ax.set_title(f"f = {f2} (Grand - Téléobjectif)")
ax.plot([proj_plane_z2, proj_plane_z2], [-0.5, 3], 'b-', label=f'Plan Projection (z={f2})')

# Projections
proj1_y2 = obj_y * f2 / obj_z1
proj2_y2 = obj_y * f2 / obj_z2
ax.plot([obj_z1, obj_z1], [0, obj_y], 'g-', lw=2, label='Objet (proche)')
ax.plot([obj_z2, obj_z2], [0, obj_y], 'm-', lw=2, label='Objet (loin)')
ax.plot([cp_z, obj_z1], [0, obj_y], 'g:') # Projector 1
ax.plot([cp_z, obj_z2], [0, obj_y], 'm:') # Projector 2
ax.plot([proj_plane_z2, proj_plane_z2], [0, proj1_y2], 'g-', lw=4, label=f'Proj 1 (h={proj1_y2:.2f})')
ax.plot([proj_plane_z2, proj_plane_z2], [0, proj2_y2], 'm-', lw=4, label=f'Proj 2 (h={proj2_y2:.2f})')
ax.plot(cp_z, 0, 'ro', label='CP')
ax.grid(True)
ax.legend(fontsize='small', loc='upper right')
ax.set_xlabel("z")

ax.set_xlim(-1, 10)
ax.set_ylim(-0.5, 3)

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.savefig('perspective_focal_length.png')
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth, keepaspectratio]{perspective_focal_length.png}
\caption{Comparaison de la taille projetée pour un objet à deux distances différentes, avec une petite distance focale (gauche) et une grande distance focale (droite). La différence de taille projetée est plus marquée avec un petit f.}
\label{fig:perspective_focal_length}
\end{figure}


\subsubsection{Volume de vue (View Frustum) et Clipping}
En pratique, on ne projette pas tout l'espace 3D. On définit un volume de vue (View Frustum), généralement une pyramide tronquée, qui délimite la portion de l'espace visible par la caméra.
Ce volume est défini par 6 plans :
\begin{itemize}
    \item Plan proche (Near plane) : $z = z_{near}$ (ou $z = -n$)
    \item Plan lointain (Far plane) : $z = z_{far}$ (ou $z = -f$)
    \item Plans gauche/droite/haut/bas (Left/Right/Top/Bottom) : Ces plans passent par le CP et les bords de la "fenêtre" définie sur le plan proche.
\end{itemize}
Le processus de \textbf{clipping} consiste à éliminer toutes les primitives géométriques (ou parties de primitives) qui se trouvent en dehors de ce volume de vue.

\textbf{Pourquoi les plans Near et Far ?}
\begin{itemize}
    \item Éviter la division par zéro (ou un nombre très petit) dans les calculs de projection si $z$ est proche de 0 (CP). Le plan Near impose $z \ge z_{near} > 0$.
    \item Gérer les primitives qui pourraient se trouver derrière la caméra.
    \item Limiter la plage de valeurs de profondeur à traiter, ce qui est crucial pour la précision du \textbf{Z-buffer} (tampon de profondeur). Le Z-buffer stocke la valeur de profondeur pour chaque pixel afin de déterminer quelle surface est visible. Il utilise une précision limitée (e.g., float 16/24/32 bits). Une plage de profondeur $[z_{near}, z_{far}]$ trop grande, surtout avec un $z_{near}$ très petit, peut entraîner des erreurs d'arrondi et des artefacts visuels ("Z-fighting") où des surfaces proches se "battent" pour savoir laquelle est devant.
\end{itemize}

\subsubsection{Passage en Coordonnées Normalisées (NDC)}
Avant la projection finale en 2D et le mapping vers l'écran, il est courant de normaliser le volume de vue (le frustum perspectif) en un volume canonique, généralement un cube $[-1, 1]^3$. Cet espace est appelé Normalized Device Coordinates (NDC).
Cette transformation simplifie les étapes ultérieures comme le clipping (qui se fait alors contre les faces du cube unité) et la projection orthographique finale (qui devient triviale).

La matrice de transformation $M_{persp \to NDC}$ qui mappe le frustum perspectif défini par $(left, right, bottom, top, near, far)$ vers le cube NDC $[-1, 1]^3$ est donnée par :
\[
M_{persp \to NDC} = \begin{pmatrix}
\frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\
0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\
0 & 0 & -\frac{f+n}{f-n} & -\frac{2fn}{f-n} \\
0 & 0 & -1 & 0
\end{pmatrix}
\]
(Note: Cette matrice suppose un système de coordonnées caméra regardant vers -z, avec near=n>0 et far=f>n. Des variations existent selon les conventions +/-z, n/f positifs/négatifs).

Après application de cette matrice et division par $w$, un point $(x_c, y_c, z_c)$ dans le repère caméra qui était à l'intérieur du frustum se retrouvera avec des coordonnées $(x_{ndc}, y_{ndc}, z_{ndc})$ comprises entre -1 et 1.

\subsubsection{Transformation complète}
La transformation complète d'un point $P_w$ en coordonnées monde vers ses coordonnées finales $P_{screen}$ sur l'écran implique la chaîne suivante :
\[ P_{screen} = M_{viewport} \cdot M_{ortho} \cdot M_{persp \to NDC} \cdot M_{world \to cam} \cdot P_w \]
où :
\begin{itemize}
    \item $M_{world \to cam}$ : Transformation du repère monde au repère caméra (changement de base).
    \item $M_{persp \to NDC}$ : Transformation du frustum perspectif vers le cube NDC.
    \item $M_{ortho}$ : Projection orthographique triviale (ignorer z, ou la matrice identité si z est déjà géré).
    \item $M_{viewport}$ : Transformation des coordonnées NDC vers les coordonnées pixels de la fenêtre d'affichage (Viewport).
\end{itemize}
Souvent, $M_{ortho} \cdot M_{persp \to NDC}$ est combinée en une seule matrice de projection. La combinaison $M_{proj} \cdot M_{view} = M_{persp \to NDC} \cdot M_{world \to cam}$ est fréquemment précalculée.


\end{document}
```